<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lite Spaceflight Sim - Phase 8 (Saving)</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
        #hud {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 16px;
            z-index: 10;
            text-shadow: 1px 1px 2px black;
        }
        
        /* --- NEW: Style for Save/Load buttons --- */
        #saveControls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 10;
        }
        #saveControls button {
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 14px;
            background-color: #333;
            color: white;
            border: 1px solid white;
            padding: 5px 10px;
            cursor: pointer;
        }
        #saveControls button:hover {
            background-color: #555;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="hud">
        Altitude: 0 m<br>
        Velocity: 0 m/s<br>
        <br>
        Apoapsis: 0 m<br>
        Periapsis: 0 m<br>
        <br>
        Time Warp: 1x
    </div>
    
    <div id="saveControls">
        <button id="saveButton">Save Game</button>
        <button id="loadButton">Load Game</button>
    </div>

    <script>
        // --- 1. SETUP ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const hud = document.getElementById('hud');
        
        // --- NEW: Get buttons ---
        const saveButton = document.getElementById('saveButton');
        const loadButton = document.getElementById('loadButton');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // --- 2. PHYSICS & SCALING (Untouched) ---
        const GM_EARTH = 3.986004418e14 / 16.0;
        const GM_MOON = 4.9048695e12 / 16.0;
        const EARTH_RADIUS = 6371000 / 4;
        const MOON_RADIUS = 1737000 / 4;
        const MOON_DISTANCE = (384400000 / 4) / 2;
        const SHIP_THRUST_ACCEL = 25.0;
        const SHIP_ROTATION_SPEED = 90.0;
        const SHIP_HEIGHT = 10;
        const SHIP_WIDTH = 5;
        const SAFE_LANDING_SPEED = 20.0;
        const MAX_ZOOM = 1.0;
        const MIN_ZOOM = 0.0000001;

        // --- 3. GAME OBJECTS (Untouched) ---
        let ship = {}; 
        const earth = {
            x: 0, y: 0,
            radius: EARTH_RADIUS,
            gm: GM_EARTH
        };
        const moon = {
            x: MOON_DISTANCE, y: 0,
            radius: MOON_RADIUS,
            gm: GM_MOON
        };
        const camera = {
            x: 0,
            y: 0,
            zoom: 0.0002
        };
        let trajectory = {
            path: [],
            apoapsis: 0,
            periapsis: 0
        };
        let isMapView = false;
        let historyLog = [];
        let lastHistorySave = 0;

        // --- 4. CONTROLS & TIME (Untouched) ---
        const keys = {
            ArrowUp: false,
            ArrowLeft: false,
            ArrowRight: false,
            '=': false,
            '-': false,
            '[': false,
            ']': false,
            'm': false,
            'r': false,
        };
        const timeWarpLevels = [1, 5, 10, 50, 100, 500, 1000, 10000];
        let timeWarpIndex = 0;
        let lastTime = 0; 
        
        window.addEventListener('keydown', (e) => {
            if (e.key in keys) keys[e.key] = true;
            if (e.key === ']') {
                timeWarpIndex = Math.min(timeWarpIndex + 1, timeWarpLevels.length - 1);
            }
            if (e.key === '[') {
                timeWarpIndex = Math.max(timeWarpIndex - 1, 0);
            }
        });
        
        window.addEventListener('keyup', (e) => {
            if (e.key in keys) keys[e.key] = false;
            if (e.key === 'm' || e.key === 'M') {
                isMapView = !isMapView; 
            }
            if (e.key === 'r' || e.key === 'R') {
                if (historyLog.length > 0) {
                    console.log("Rewinding 10 seconds!");
                    ship = JSON.parse(JSON.stringify(historyLog[0]));
                    historyLog = [];
                    trajectory.path = [];
                    timeWarpIndex = 0;
                } else {
                    console.log("History log is empty.");
                }
            }
        });

        // --- 5. PHYSICS & GAME LOGIC ---

        // --- NEW: Save/Load Functions ---
        const SAVE_KEY = "sfs_lite_savegame";

        function saveGame() {
            if (ship.landedOn) {
                // We only save if the ship is landed
                const saveString = JSON.stringify(ship);
                localStorage.setItem(SAVE_KEY, saveString);
                alert("Game Saved!");
            } else {
                alert("You can only save the game while landed.");
            }
        }
        
        function loadGame() {
            const saveString = localStorage.getItem(SAVE_KEY);
            if (saveString) {
                // Load the ship data
                ship = JSON.parse(saveString);
                
                // Reset other systems to avoid bugs
                historyLog = [];
                trajectory.path = [];
                timeWarpIndex = 0;
                isMapView = false; // Go back to ship view
                
                alert("Game Loaded!");
            } else {
                alert("No save game found!");
            }
        }
        
        // --- NEW: Hook up buttons ---
        saveButton.addEventListener('click', saveGame);
        loadButton.addEventListener('click', loadGame);

        // --- All other functions are UNTOUCHED ---

        function applyGravity(ship, body, dt) {
            const dx = body.x - ship.x;
            const dy = body.y - ship.y;
            const distSq = dx * dx + dy * dy;
            const dist = Math.sqrt(distSq);
            
            const accel = body.gm / distSq;
            const ax = (dx / dist) * accel;
            const ay = (dy / dist) * accel;

            ship.vx += ax * dt;
            ship.vy += ay * dt;
            
            return dist; 
        }

        function getGravityAccel(ghostShip, body) {
            const dx = body.x - ghostShip.x;
            const dy = body.y - ghostShip.y;
            const distSq = dx * dx + dy * dy;
            const dist = Math.sqrt(distSq);
            
            let radiusUsed = Math.max(dist, body.radius);
            let distSqUsed = radiusUsed * radiusUsed;
            
            const accel = body.gm / distSqUsed;
            const ax = (dx / dist) * accel;
            const ay = (dy / dist) * accel;
            
            return { ax, ay, dist };
        }

        function checkLanding(ship, body, dist, dt) {
            if (dist < (body.radius + SHIP_HEIGHT / 2)) {
                const totalVelocity = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
                
                if (totalVelocity > SAFE_LANDING_SPEED) {
                    console.log("CRASH! Speed: " + totalVelocity);
                    resetShip();
                } else {
                    landShip(ship, body);
                }
            }
        }
        
        function landShip(ship, body) {
            ship.landedOn = body;
            ship.vx = 0;
            ship.vy = 0;
            
            const angleToBody = Math.atan2(ship.y - body.y, ship.x - body.x);
            const landRadius = body.radius + (SHIP_HEIGHT / 2);
            ship.x = body.x + Math.cos(angleToBody) * landRadius;
            ship.y = body.y + Math.sin(angleToBody) * landRadius;
            ship.angle = angleToBody + Math.PI / 2;
        }

        function resetShip() {
            ship = {
                x: 0,
                y: -EARTH_RADIUS,
                vx: 0,
                vy: 0,
                angle: 0, 
                isThrusting: false,
                landedOn: null
            };
            landShip(ship, earth); 
            timeWarpIndex = 0;
            historyLog = [];
        }

        // --- TRAJECTORY CALCULATION (Untouched) ---
        const PREDICTION_STEPS = 1000;
        const PREDICTION_STEP_TIME = 2;

        function calculateTrajectory(ship) {
            let ghost = {
                x: ship.x,
                y: ship.y,
                vx: ship.vx,
                vy: ship.vy
            };
            
            let pathPoints = [];
            let maxDist = 0;
            let minDist = Infinity;

            for (let i = 0; i < PREDICTION_STEPS; i++) {
                let accelE = getGravityAccel(ghost, earth);
                let accelM = getGravityAccel(ghost, moon);
                
                let ax = accelE.ax + accelM.ax;
                let ay = accelE.ay + accelM.ay;
                
                ghost.vx += ax * PREDICTION_STEP_TIME;
                ghost.vy += ay * PREDICTION_STEP_TIME;
                ghost.x += ghost.vx * PREDICTION_STEP_TIME;
                ghost.y += ghost.vy * PREDICTION_STEP_TIME;
                
                pathPoints.push({ x: ghost.x, y: ghost.y });
                
                maxDist = Math.max(maxDist, accelE.dist);
                minDist = Math.min(minDist, accelE.dist);
            }
            
            return {
                path: pathPoints,
                apoapsis: maxDist - earth.radius,
                periapsis: minDist - earth.radius
            };
        }

        // --- 6. UPDATE FUNCTION (Untouched from Phase 7) ---
        function update(dt) {
            if (!isMapView) {
                if (keys['=']) camera.zoom *= 1.02;
                if (keys['-']) camera.zoom /= 1.02;
                camera.zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, camera.zoom));
            } else {
                camera.zoom = 0.000005;
            }

            if (ship.landedOn) {
                if (keys.ArrowLeft) {
                    ship.angle -= (SHIP_ROTATION_SPEED * Math.PI / 180) * dt;
                }
                if (keys.ArrowRight) {
                    ship.angle += (SHIP_ROTATION_SPEED * Math.PI / 180) * dt;
                }
                
                ship.isThrusting = false;
                if (keys.ArrowUp) {
                    ship.landedOn = null; 
                    ship.isThrusting = true;
                    const accel_x = Math.cos(ship.angle - Math.PI / 2) * SHIP_THRUST_ACCEL;
                    const accel_y = Math.sin(ship.angle - Math.PI / 2) * SHIP_THRUST_ACCEL;
                    ship.vx += accel_x * dt;
                    ship.vy += accel_y * dt;
                }
            } else {
                // IN-FLIGHT LOGIC
                if (keys.ArrowLeft) {
                    ship.angle -= (SHIP_ROTATION_SPEED * Math.PI / 180) * dt;
                }
                if (keys.ArrowRight) {
                    ship.angle += (SHIP_ROTATION_SPEED * Math.PI / 180) * dt;
                }
                ship.isThrusting = false;
                if (keys.ArrowUp) {
                    ship.isThrusting = true;
                    const accel_x = Math.cos(ship.angle - Math.PI / 2) * SHIP_THRUST_ACCEL;
                    const accel_y = Math.sin(ship.angle - Math.PI / 2) * SHIP_THRUST_ACCEL;
                    ship.vx += accel_x * dt;
                    ship.vy += accel_y * dt;
                }
                let distToEarth = applyGravity(ship, earth, dt);
                let distToMoon = applyGravity(ship, moon, dt);
                ship.x += ship.vx * dt;
                ship.y += ship.vy * dt;
                checkLanding(ship, earth, distToEarth, dt);
                checkLanding(ship, moon, distToMoon, dt);
            }
            
            // Calculate trajectory and update HUD
            let altitude, velocity, apText, peText;

            let distToEarthCenter = Math.sqrt(Math.pow(ship.x - earth.x, 2) + Math.pow(ship.y - earth.y, 2));
            altitude = (distToEarthCenter - earth.radius).toFixed(0);
            velocity = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy).toFixed(2);

            if (ship.landedOn) {
                apText = "Landed";
                peText = "Landed";
                trajectory.path = []; 
            } else {
                trajectory = calculateTrajectory(ship);
                apText = `${trajectory.apoapsis.toFixed(0)} m`;
                peText = `${trajectory.periapsis.toFixed(0)} m`;
            }
            
            hud.innerHTML = `Altitude: ${altitude} m<br>Velocity: ${velocity} m/s<br><br>
                             Apoapsis: ${apText}<br>Periapsis: ${peText}<br><br>
                             Time Warp: ${timeWarpLevels[timeWarpIndex]}x`;
        }
        
        // --- 7. DRAW FUNCTION (Untouched from Phase 7) ---
        
        function drawTrajectory(ctx) {
            if (trajectory.path.length === 0) {
                return;
            }
            
            ctx.beginPath();
            ctx.moveTo(ship.x, ship.y); 
            for (const point of trajectory.path) {
                ctx.lineTo(point.x, point.y);
            }
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1 / camera.zoom;
            ctx.stroke();
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(camera.zoom, camera.zoom);

            if (!isMapView) {
                camera.x = ship.x;
                camera.y = ship.y;
            } else {
                camera.x = earth.x;
                camera.Y = earth.y;
            }
            ctx.translate(-camera.x, -camera.y);
            
            drawTrajectory(ctx);
            
            // Draw Earth
            ctx.beginPath();
            ctx.arc(earth.x, earth.y, earth.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#3a86ff'; 
            ctx.fill();

            // Draw Moon
            ctx.beginPath();
            ctx.arc(moon.x, moon.y, moon.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#8e9aaf';
            ctx.fill();

            // Draw the Ship
            ctx.save();
            ctx.translate(ship.x, ship.y);
            ctx.rotate(ship.angle); 
            ctx.lineWidth = 1 / camera.zoom; 
            ctx.beginPath();
            ctx.moveTo(0, -SHIP_HEIGHT / 2);
            ctx.lineTo(SHIP_WIDTH / 2, SHIP_HEIGHT / 2);
            ctx.lineTo(-SHIP_WIDTH / 2, SHIP_HEIGHT / 2);
            ctx.closePath();
            ctx.strokeStyle = 'white';
            ctx.stroke();
            if (ship.isThrusting) {
                ctx.beginPath();
                ctx.moveTo(0, SHIP_HEIGHT / 2);
                ctx.lineTo(-SHIP_WIDTH / 2, SHIP_HEIGHT / 2 + 7);
                ctx.lineTo(SHIP_WIDTH / 2, SHIP_HEIGHT / 2 + 7);
                ctx.closePath();
                ctx.fillStyle = 'orange';
                ctx.fill();
            }
            ctx.restore(); 
            ctx.restore();
        }

        // --- 8. GAME LOOP (Untouched from Phase 7) ---
        function gameLoop(timestamp) {
            
            if (timestamp - lastHistorySave > 100) {
                lastHistorySave = timestamp;
                historyLog.push(JSON.parse(JSON.stringify(ship)));
                if (historyLog.length > 100) {
                    historyLog.shift();
                }
            }
            
            let dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            
            if (dt > 0.1) dt = 0.1; 
            
            let warpedDt = dt * timeWarpLevels[timeWarpIndex];
            
            let steps = Math.min(100, Math.max(1, warpedDt / 0.016)); 
            let stepDt = warpedDt / steps;
            
            for (let i = 0; i < steps; i++) {
                update(stepDt);
            }
            
            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- START THE GAME (Untouched) ---
        resetShip(); 
        lastTime = performance.now(); 
        requestAnimationFrame(gameLoop); 

    </script>
</body>
</html>
